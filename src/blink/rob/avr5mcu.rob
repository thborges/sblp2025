
use intfs.mcu;
use intfs.ports;
use avr5regs;

void __delay_us();
void busy_wait_loop5(uint16 count);

type avr5mcu implements mcu {
	
	uint32 clock() inline {
		return 16E6;
	}

	void set_interruptions(bool enabled) inline {
		if enabled {
			asm "sei";
		} else  {
			asm "cli";
		}
	}

	b0 implements digitalport {
		void mode(port_mode m) inline { ddrb.b0 = m; }
		void set(bool v) inline { portb.b0 = v; }
		bool get() inline { return portb.b0; }
	}

	b5 implements digitalport {
		void mode(port_mode m) inline { ddrb.b5 = m; }
		void set(bool v) inline { portb.b5 = v; }
		bool get() inline { return portb.b5; }
	}

	void bwait_loop_2(uint16 count) inline {
		// trusting that ABI will put count parameter in r25:r24
		asm "1: sbiw r24,1"; // 2 cycles
		asm "   brne 1b";    // 2 cycles while count > 0 and 1 cycles at the end
		// cycles total = 4*count - 1
	}

	void busy_wait_loop5(uint16 count) noopt {
		// trusting that ABI will put the count parameter in r25:r24
		// cycles total: 3 + count*5-1 + 3
		//   +2 (ldi r25:r24 prior to cal) + count*5 - 1 + 3
		//   +1 (ser)
		//   +count*5-1 (loop)
		//   +2 (rjmp)
		//   +1 (ret)
		asm "ser r18
			 loop: subi r18,1
				   sbci r24,0
				   sbci r25,0
				   brne loop
			 rjmp end
			 end: "; // a ret is appended here
	}
	
	// secure range 1 -- 5460
	void wait_ms(uint16 ms) {
		count = uint16(clock() / 1280e3) * ms - 1;
		busy_wait_loop5(count);
	}
}

